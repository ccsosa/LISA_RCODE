rm(list = ls());gc()
#load libraries
require(readxl);require(dplyr);require(geodata);
require(sf);require(matrixStats);require(parallel);
require(ggpmisc);require(caret);require(xgboost)
require(ggplot2);require(MetBrewer);require(corrplot);
require(factoextra);require(FactoMineR);require(xlsx);require(rgeoda);library(car)
#data_dir <- "D:/CIAT_DEFORESTATION/RESULTS"
#outdir
#folder to save files
out_dir <- "D:/CIAT_DEFORESTATION/RESULTS/REG"
#create summary folder
if(!dir.exists(paste0(out_dir))){
  dir.create(paste0(out_dir))
}
load("D:/CIAT_DEFORESTATION/RESULTS/6_FOREST_LU_LUIEMISS.RData")

# parameters
cv_folds = 10 #complete sets of folds to compute
cv_repeats = 10 #for repeated k-fold cross-validation 
min_rsamp = 5 #minimum number of resamples used before models were removed
tlength = 100 #initialized models 
# number of model runs
nrun = 5 #vary according to the number of runs required
################################################################################
vars <- c(#"gain_2000-2020_ha",
  "tc_loss_med_11_20",
  "ABG_2010_2020",
  #"carbon_gross_11_20",
  #"tc_loss_med_prop",
  "protarea_area",            
  #"protarea_prop",
  "cattle_mean",
  "goat_mean",
  "sheep_mean",
  "lud_45",
  "n_fatalities",
  #"n_events",
  #"n_fatalities_total",
  #"n_events_total",
  #new
  "Tree cover",
  "Shrubland",
  "Grassland",
  "Cropland",
  "Built-up",
  #"Bare/sparse vegetation",
  #"Snow and Ice",
  #"Permanent water bodies",
  #"Herbaceous wetland",
  #"Mangroves",
  #"Moss and lichen",
  "LUC_emissions"
)
################################################################################
xgb.model.function <- function(run, cv_folds, cv_repeats, min_rsamp, tlength,fseed,x_shp,vars){
  x_1 <- x_shp
  x_1$geometry <- NULL
  x_1 <- x_1[,vars]
  data_model <- x_1
  fseed=10000 #seed defined using variable run
  
  # start time 
  time_start <- Sys.time()
  
  
  # create training and testing data set
  set.seed(fseed) # set seed for reproducibility
  indata <- caret::createDataPartition(y = data_model$n_fatalities, p = 0.8)[[1]] # index for testing and training data
  training <- data_model[indata,] 
  testing <- data_model[-indata,]
  
  # trainControl object for repeated cross-validation with random search 
  adaptControl <- caret::trainControl(method = "adaptive_cv",#the full set of resamples is not run for each model. As resampling continues, a futility analysis is conducted and models with a low probability of being optimal are removed
                               number = cv_folds, 
                               repeats = cv_repeats,
                               adaptive = list(min = min_rsamp,#the minimum number of resamples used before models are removed
                                               alpha = 0.05, #the confidence level of the one-sided intervals used to measure futility
                                               method = "gls",
                                               complete = FALSE),
                               search = "random",#describing how the tuning parameter grid is determined (random search procedure)
                               verbose=F,
                               allowParallel = TRUE)
  
  # train model
  set.seed(fseed) # set seed for reproducibility
  xgb_model <- caret::train(n_fatalities ~ ., data = training,
                     method = "xgbTree", 
                     trControl = adaptControl,
                     metric = "RMSE",
                     tuneLength = tlength,#By default, this argument is the number of levels for each tuning parameters that should be generated by train. If trainControl has the option search = "random", this is the maximum number of tuning parameter combinations that will be generated by the random search
                     na.action = na.pass,verbose=F)
  
  # model summary
  model_summary <- xgb_model$results %>%
    arrange(RMSE) %>%
    head(1) %>%
    transmute(rsquared = Rsquared, rmse = RMSE, eta, max_depth, gamma, colsample_bytree, 
              min_child_weight, subsample, nrounds)
  
  # prepare testing data
  x_test <- select(testing, -df_ha)
  y_test <- testing$df_ha
  
  # apply test data to model
  predicted <- predict(xgb_model, x_test, na.action=na.pass)
  
  # calcuate residuals
  test_residuals <- y_test - predicted
  
  # calculation of rsquare
  tss <- sum((y_test - mean(y_test))^2) #total sum of squares
  rss <- sum(test_residuals^2) #residual sum of squares
  test_rsquared <- 1 - (rss/tss) #rsquare
  
  # calculate root mean square error
  test_rmse <- sqrt(mean(test_residuals^2))
  # calculate mean absolut error
  test_mae <- mean(abs(test_residuals))
  
  # model evaluation
  model_eval <- list(x_test=x_test, y_test=y_test, predicted=predicted, test_residuals=test_residuals, 
                     test_rsquared=test_rsquared, test_rmse=test_rmse, test_mae=test_mae)
  
  # variable importance
  
  #model1
  model_var_importance <- 
    xgb.importance(feature_names = dimnames(data_model[,-1])[[2]], model = xgb_model$finalModel) %>%
    transmute(Feature, Gain) %>%
    pivot_wider(names_from = Feature, values_from = Gain, names_prefix = "imp_") %>% 
    transmute(imp_gdp_perc = ifelse(exists("imp_gdp_perc"), imp_gdp_perc, 0),
              imp_rural_pop = ifelse(exists("imp_rural_pop"), imp_rural_pop, 0),
              imp_gdp_growth = ifelse(exists("imp_gdp_growth"), imp_gdp_growth, 0),
              imp_exports_gdp = ifelse(exists("imp_exports_gdp"), imp_exports_gdp, 0),
              imp_food_exports = ifelse(exists("imp_food_exports"), imp_food_exports, 0),
              imp_food_imports = ifelse(exists("imp_food_imports"), imp_food_imports, 0),
              imp_food_infl = ifelse(exists("imp_food_infl"), imp_food_infl, 0),
              imp_foreing_invest = ifelse(exists("imp_foreing_invest"), imp_foreing_invest, 0),
              imp_tmp_change = ifelse(exists("imp_tmp_change"), imp_tmp_change, 0),
              imp_dem_mdn = ifelse(exists("imp_dem_mdn"), imp_dem_mdn, 0),
              imp_trv_med = ifelse(exists("imp_trv_med"), imp_trv_med, 0),
              imp_pop_growth = ifelse(exists("imp_pop_growth"), imp_pop_growth, 0)              
    )
  
  
  # save model settings
  model_settings <- data.frame(level=level, seed=fseed, cv_folds=cv_folds, cv_repeats= cv_repeats, 
                               min_rsamp=min_rsamp, tlength=tlength)
  
  # prepare output
  output <- list(xgb_model, model_settings, model_summary, model_eval, model_var_importance, training, testing)
  names(output) <- c(paste("xgb_model", level, sep = "_"),
                     paste("model_settings", level, sep = "_"),
                     paste("model_summary", level, sep = "_"),
                     paste("model_evaluation", level, sep = "_"),
                     paste("model_var_importance", level, sep = "_"),
                     paste("data_training", level, sep = "_"),
                     paste("data_testing", level, sep = "_"))
  
  # stop time
  time_end <- Sys.time()
  time_run <- time_end-time_start
  
  # print run time
  cat(crayon::green(paste("[model run time: ", round(time_run, 2), "]\n", sep="")))
  
  # write time file
  run_time <- data.frame(time_start, time_end, time_run, level, run)
  
  write.table(run_time, file.path(path_output, "run_time.csv"), 
              sep = ",", col.names = FALSE, append=TRUE, row.names = FALSE)
  
  #return xgb output
  assign(paste("output", level, fseed, sep = "_"), output)
}

